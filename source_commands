#!/bin/sh

find_images() {
    docker images "$1"  # This always returns 0, there must be a better way
    #docker inspect --format='{{ .RepoTags }}' "$1"
}

image_exists() {
    # See if a Docker image named $1 exists locally.

    # Will always return 1 if inspecting a container instead of an image
    if ! docker inspect --format '{{ .Author }}' "$1" >&/dev/null ; then
        echo "failed at author"
        return 1
    fi

    # Check that it's really the name of the image, not a prefix
    if docker inspect --format '{{ .Id }}' "$1" | grep -q "^$1" ; then
        return 1
    fi
    return 0
}

enumerate_devices() {
    # Add a bunch of (optional) devices
    # (Don't add them unconditionally: if they don't exist, it
    # would prevent the container from starting)
    # FIXME: zsh annoyingly complains when no matches are found for those

    DEVICES=
    for DEV in /dev/kvm /dev/dri/* /dev/snd/*; do
        if [ -b "$DEV" -o -c "$DEV" ]; then
            DEVICES="$DEVICES --device $DEV:$DEV"
        fi
    done
    echo "$DEVICES"
}

enumerate_volumes() {
    # And a few (optional) files
    # (Like in enumerate_devices, they don't always exist everywhere)

    RW_VOLS="
        /tmp/.X11-unix
        /run/user
        `pwd`
    "
    RO_VOLS="
        /etc/passwd
        /etc/group
        /etc/localtime
    "

    VOLUMES=
    for VOL in $RW_VOLS ; do
        if [ -e "$VOL" ]; then
            VOLUMES="$VOLUMES --volume $VOL:$VOL"
        fi
    done

    for VOL in $RO_VOLS ; do
        if [ -e "$VOL" ]; then
            VOLUMES="$VOLUMES --volume $VOL:$VOL:ro"
        fi
    done

    # User arguments
    # If any arguments correspond to files present on the host, bind-mount
    # the parent directory
    for ARG in "$@"; do
        verbose_echo "     -> $ARG"
        if [[ $ARG == -* ]]; then
            verbose_echo "Flag detected, ignoring: $ARG"
        else
            # Deal with symlinks and relative paths
            ARG=$(readlink --canonicalize --no-newline $ARG)
            if [ -z $ARG ]; then
                verbose_echo "not a file: $ARG"
            else
                DIRNAME="$(dirname "$ARG")"
                if [ -d "$DIRNAME" ]; then
                    # fixme: what about important directories like /, /usr...?
                    VOLUMES="$VOLUMES --volume $DIRNAME:$DIRNAME"
                    verbose_echo "Volume detected: $DIRNAME"
                else
                    verbose_echo "$DIRNAME is not a dir"
                fi
            fi
        fi
    done

    echo "$VOLUMES"
}

enumerate_envvars() {
    echo $(env | sort | cut -d= -f1 | awk '{print "--env", $1}')
}

verbose_echo() {
    if [ ! -z $CLINK_VERBOSITY ]; then
        fd="--stderr"
    fi
    logger --id $fd --tag "clink" "$@"
    #>&2 echo "$@" | logger --id --stderr --tag "[clink]"
}

print_run_cmd() {
    RUNFLAGS="
        DASHT
        DEVICES
        ENTRYPOINT
        ENVVARS
        INTERACTIVE
        PORTS
        USER_ID
        VOLUMES
        WORKDIR
        "
    for FLAG in $RUNFLAGS; do
        echo -n "$FLAG:"
        echo "$(echo "${!FLAG}" | sed 's/--/\n--/g')"
    done
}

docker_run_image() {
    # Run Docker image.
    # Arguments: <imagename> [optional args passed at the end of docker run...]

    # FIXME
    docker rm ${1}-run

    IMAGE=$1
    shift 
    DEVICES=$(enumerate_devices)
    VOLUMES=$(enumerate_volumes "$@")
    ENVVARS=$(enumerate_envvars)
    PORTS="--publish-all"
    WORKDIR="--workdir $(pwd)"
    USER_ID="--user $(id -u)"
    INTERACTIVE="--interactive"

    # Check if we are on a tty to decide whether to allocate one
    DASHT=
    tty -s && DASHT=-t

    ENTRYPOINT=
    #ENTRYPOINT="--entrypoint bash"

    verbose_echo "$(print_run_cmd)"

    docker run $DASHT \
        --name ${IMAGE}-run \
        $DEVICES \
        $ENTRYPOINT \
        $ENVVARS \
        $INTERACTIVE \
        $PORTS \
        $USER_ID \
        $VOLUMES \
        $WORKDIR \
        "$IMAGE" "$@"
}

which() {
    real_which=":"
    for which_path in /bin/which /usr/bin/which; do
        if [ -x $which_path ]; then
            real_which=$which_path
        fi
    done
    $real_which "$1" || type -a "$1" || declare -f "$1" || find_images "$1" || echo "No Docker images found named $1"
}

command_not_found() {
    if image_exists $1:latest; then
        docker_run_image "$@"
    else
        echo "$0: $1: command/image not found"
        return
    fi
}

command_not_found_handle () {
    command_not_found "$@"
}

command_not_found_handler() {
    command_not_found "$@"
}
